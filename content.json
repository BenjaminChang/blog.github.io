{"meta":{"title":"westbreeze个人博客","subtitle":"兰亭无绪，独饮清风","description":null,"author":"westbreeze","url":"http://westbreeze.cn"},"pages":[{"title":"关于我","date":"2017-08-28T15:08:06.000Z","updated":"2017-08-28T15:11:34.310Z","comments":true,"path":"about/index.html","permalink":"http://westbreeze.cn/about/index.html","excerpt":"","text":"​ 以前也在各种博客网上零星的写过一些博客。 ​ 近来想把平时做的笔记整理一下，因此创建一个博客，整理的过程也是一种回顾。 ​"}],"posts":[{"title":"使用JWT设计安全的对外接口","slug":"jwt","date":"2017-09-23T14:41:01.000Z","updated":"2017-12-02T02:16:02.164Z","comments":true,"path":"2017/09/23/jwt/","link":"","permalink":"http://westbreeze.cn/2017/09/23/jwt/","excerpt":"","text":"使用JWT（JSON Web Token）设计安全的对外接口 一、JWT简介 JWT(JSON Web Token)JWT是一种安全标准。基本思路就是用户提供用户名和密码给认证服务器，服务器验证用户提交信息信息的合法性;如果验证成功，会产生并返回一个Token（令牌），用户可以使用这个token访问服务器上受保护的资源。 一个token包含三部分：header.claims.signatureHeader头部分头部分简单声明了类型(JWT)以及产生签名所使用的算法。1234&#123; &quot;alg&quot; : &quot;AES256&quot;, &quot;typ&quot; : &quot;JWT&quot;&#125; Claims声明 声明部分是整个token的核心，表示要发送的用户详细信息。有些情况下，我们很可能要在一个服务器上实现认证，然后访问另一台服务器上的资源； 或者，通过单独的接口来生成token，token被保存在应用程序客户端（比如浏览器）使用。一个简单的声明（claim）的例子：12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; Signature签名签名的目的是为了保证上边两部分信息不被篡改。如果尝试使用Bas64对解码后的token进行修改，签名信息就会失效。一般使用一个私钥（private key）通过特定算法对Header和Claims进行混淆产生签名信息，所以只有原始的token才能于签名信息匹配。这里有一个重要的实现细节。只有获取了私钥的应用程序（比如服务器端应用）才能完全认证token包含声明信息的合法性。所以，永远不要把私钥信息放在客户端（比如浏览器）。 二、JWT流程第一步：传递自定义信息（图上是传的用户名和密码）到JWT服务端第二步：JWT服务端校验自定义信息正确后返回TOKEN第三步：客户端使用TOKEN去请求数据接口第四步：服务端校验TOKEN正确后返回数据 三、API接口设计在使用JWT的基础上，完善JWT使用http请求模式下的安全问题。解决问题1：如果token在http请求传输过程中被窃取怎么办。JWT解决方案：token是动态的，可以设置失效时间，一般一个小时失效。 解决问题2：如果请求token的自定义信息在传输过程中被窃取，就可以无限的拿到token，数据接口也就完全暴露。解决方案：获取token的时候传输自定义信息命名为ticket。ticket的组成部分分三个部分：时间戳-固定字符串SHA秘钥加密-随机整数SHA秘钥加密对整个字符串再通过自定义秘钥加密得到ticket。并且做以下三样保证： 保证ticket的动态性由于ticket前面一截是时间戳后面一截是随机整数因此ticket是动态的；2.保证ticket的不可解密性由于整个ticket采用自定义加密方式需且秘钥存在服务端，并且不知道加密算法，无法解密；3.保证ticket的时效性由于ticket前部分是时间戳，服务端设置一个过期时间，前后30分钟有效。因此ticket与token一样有个失效时间，过期无效；","categories":[{"name":"接口","slug":"接口","permalink":"http://westbreeze.cn/categories/接口/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"http://westbreeze.cn/tags/JWT/"}]},{"title":"使用lvs搭建高可用集群","slug":"lvs集群负载","date":"2017-07-15T15:10:10.000Z","updated":"2017-12-25T08:25:04.339Z","comments":true,"path":"2017/07/15/lvs集群负载/","link":"","permalink":"http://westbreeze.cn/2017/07/15/lvs集群负载/","excerpt":"","text":"lvs+keepalived+nginx+tomcat实现双机热备负载均衡 lvs简介LVS是 Linux Virtual Server 的简称，也就是Linux虚拟服务器。这是一个由章文嵩博士发起的一个开源项目，它的官方网站是 http://www.linuxvirtualserver.org 现在 LVS 已经是 Linux 内核标准的一部分。使用 LVS 可以达到的技术目标是：通过 LVS 达到的负载均衡技术和 Linux 操作系统实现一个高性能高可用的 Linux 服务器集群，它具有良好的可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的性能。LVS 是一个实现负载均衡集群的开源软件项目，LVS架构从逻辑上可分为调度层、Server集群层和共享存储。 lvs的原理以及模式介绍推荐文章：https://www.cnblogs.com/liwei0526vip/p/6370103.htm keepalived介绍 keepalived是集群管理中保证集群高可用的一个服务软件，其功能类似于heartbeat，用来防止单点故障。 keepalived工作原理 keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。 虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了。 keepalived主要有三个模块，分别是core、check和vrrp。core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式。vrrp模块是来实现VRRP协议的。 下面开始介绍一种集群方案（网络拓扑图如下图所示）由于机器有限：使用两台机器完成192.168.1.44 虚拟ip vip192.168.1.38 lvs主192.168.1.40 lvs备192.168.1.38 nginx192.168.1.40 nginx192.168.1.38:8080 tomcat1192.168.1.38:8081 tomcat2192.168.1.40:8080 tomcat3192.168.1.40:8081 tomcat4 下面开始动手搭建： 1）安装IPVSADM知识点：IPVSADM理解为IPVS管理工具；LVS（Linux Virtual Server）的核心为IPVS（IP Virtual Server），从Linux内核版本2.6起，IPVS模块已经编译进了Linux内核。使用yum命令进行安装，系统会选择最适合内核版本的ipvsadm1yum -y install ipvsadm 2.安装keepalived123456789yum -y install openssl-devel wget http://www.keepalived.org/software/keepalived-1.2.7.tar.gz wget http://mirror.centos.org/centos/6/os/x86_64/Packages/popt-static-1.13-7.el6.x86_64.rpm yum -y install popt-static-1.13-7.el6.x86_64.rpm yum -y install kernel-devel make gcc openssl-devel libnl* popt* ln -s /usr/src/kernels/2.6.32-220.13.1.el6.x86_64/ /usr/src/linux tar zxvf keepalived-1.2.7.tar.gz cd keepalived-1.2.7 ./configure 注意执行./configure后显示为，五个yes 不对的话找下原因 继续执行123456make &amp;&amp; make install cp /usr/local/etc/rc.d/init.d/keepalived /etc/rc.d/init.d/ cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/ mkdir /etc/keepalived cp /usr/local/etc/keepalived/keepalived.conf /etc/keepalived/ cp /usr/local/sbin/keepalived /usr/sbin/ keepalived安装完成。 3.配置keepalivedThe First：打开IP Forward 功能（LVS现有三种负载均衡规则都需要打开此功能，如果不打开此功能，下面的配置配得再好都无济于事。）1vi /etc/sysctl.conf 打开后修改里面“net.ipv4.ip_forward = 0” 改为 “net.ipv4.ip_forward = 1” 修改好后保存退出，执行如下命令使设置立即生效1sysctl -p KeepAlivde配置文件修改配置文件在这个位置： /etc/keepalived/keepalived.conf启动KeepAlived时，它默认会去/etc/keepalived下面找它的配置文件，所以上面命令中我们已经将这个配置文件复制过来了。现在进行修改：1vi /etc/keepalived/keepalived.conf 下面是我的配置，各有不同需要相应的调整12345678910111213141516171819202122232425! Configuration File for keepalivedglobal_defs &#123; notification_email &#123; test@sina.com &#125; notification_email_from admin@test.com smtp_server 127.0.0.1 smtp_connect_timeout 30 router_id LVS_MASTER&#125;vrrp_instance VI_1 &#123; state MASTER interface eth2 virtual_router_id 60 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.1.44 &#125;&#125; 以上就完成了keepAlived的配置，下面进行启动12chkconfig keepalived on service keepalived start 查看进程1ps aux | grep keepalived 结果如图Keepalived正常运行时，共启动3个进程，其中一个进程是父进程，负责监控其子进程；一个是vrrp子进程；另外一个是checkers子进程。如果此时只看到2个进程，请从安装keepalived的步骤重新执行。 查看下虚拟IP是否已经加上（重要）1ip a 虚拟ip加上了如果没有加上可能是keepalived配置配错了interface eth2 这里要注意一下根据自己机器的网卡来写 添加虚拟ip参考http://blog.csdn.net/huoyuanshen/article/details/68483188 还有3个命令在先列示下，并不用执行显示集群中服务器ip信息：ipvsadm -ln查看日志：tail -f /var/log/messages查看请求转发情况：ipvsadm -lcn | grep 虚拟IP 4.WEB服务器WEB1_RealServer的配置vim /etc/init.d/realserver.sh输入12345678910111213141516171819202122232425262728#!/bin/bash SNS_VIP=192.168.10.100 . /etc/rc.d/init.d/functions case &quot;$1&quot; in start) ifconfig lo:0 $SNS_VIP netmask 255.255.255.255 broadcast $SNS_VIP /sbin/route add -host $SNS_VIP dev lo:0 echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce sysctl -p &gt;/dev/null 2&gt;&amp;1 echo &quot;RealServer Start OK&quot; ;; stop) ifconfig lo:0 down route del $SNS_VIP &gt;/dev/null 2&gt;&amp;1 echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce echo &quot;RealServer Stoped&quot; ;; *) echo &quot;Usage: $0 &#123;start|stop&#125;&quot; exit 1 esac exit 0 5.安装4个tomcat如下192.168.1.38:8080 tomcat1192.168.1.38:8081 tomcat2192.168.1.40:8080 tomcat3192.168.1.40:8081 tomcat4 6.启动虚拟ip脚本 7.nginx配置安装这里就不写了，直接上配置1234567891011121314151617upstream tomcat &#123; #sticky; server 192.168.1.38:8080 weight=1; server 192.168.1.38:8081 weight=1; server 192.168.1.40:8080 weight=1; server 192.168.1.40:8081 weight=1;&#125;location ^~ / &#123; proxy_pass http://tomcat; proxy_redirect off ; proxy_set_header Host $host:80; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; &#125; 8.从节点配置7.从节点配置1）从LVS_MASTER克隆一个LVS_BACKUP服务器，然后修改其中的参数，MASTER与BACKUP配置仅三处不同：global_defs中的router_id、vrrp_instance中的state、priorityrouter_id LVS_BACKUPstate BACKUPpriority 90 配置全部完成之后全部服务启动12345671.启动虚拟ip脚本 sh /etc/init.d/realserver.sh start2.启动keepalivedservice keepalived start3.启动nginx/usr/local/nginx/sbin/nginx4.启动tomcat 分别修改Tomcat的ROOT目录下面的index.jsp写入内容，已40机器的8080tomcat为例HI ,I AM TOMCAT8080, MY IP IS 192.168.1.40 . 效果：访问http://192.168.1.44 不停刷新 会分别在两台机器 四台tomcat上不停的切换 至此lvs+keepalived+nginx+tomcat实现双机热备负载均衡 搭建成功 参考文章：http://blog.csdn.net/huoyuanshen/article/details/68483188https://www.cnblogs.com/liwei0526vip/p/6370103.htmlhttp://blog.csdn.net/tengyuantuohai/article/details/19639671http://outofmemory.cn/wiki/keepalived-configuration 推荐文章：http://www.linuxvirtualserver.org/zh/lvs1.htmlhttp://www.linuxvirtualserver.org/zh/lvs2.htmlhttp://www.linuxvirtualserver.org/zh/lvs3.htmlhttp://www.linuxvirtualserver.org/zh/lvs4.html","categories":[{"name":"集群与负载","slug":"集群与负载","permalink":"http://westbreeze.cn/categories/集群与负载/"}],"tags":[{"name":"webService","slug":"webService","permalink":"http://westbreeze.cn/tags/webService/"}]},{"title":"多域名指向统一个nginx配置","slug":"多域名指向同一个nginx","date":"2017-04-01T10:45:36.000Z","updated":"2017-11-01T06:29:41.679Z","comments":true,"path":"2017/04/01/多域名指向同一个nginx/","link":"","permalink":"http://westbreeze.cn/2017/04/01/多域名指向同一个nginx/","excerpt":"","text":"多个域名指向同一个nginx配置 server { listen 80; server_name test1.test.com test2.test.com; #charset koi8-r; #access_log logs/host.access.log main; location ^~ /sdk/ { proxy_pass http://passport; proxy_redirect off ; proxy_set_header Host $host:80; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; } } 这里遇到一个问题 最后一个域名后面加个空格会报错","categories":[{"name":"nginx","slug":"nginx","permalink":"http://westbreeze.cn/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://westbreeze.cn/tags/nginx/"}]},{"title":"python读取json菜单小工具","slug":"python读取json菜单","date":"2017-03-01T14:06:48.000Z","updated":"2017-11-29T09:07:01.222Z","comments":true,"path":"2017/03/01/python读取json菜单/","link":"","permalink":"http://westbreeze.cn/2017/03/01/python读取json菜单/","excerpt":"","text":"python读取json菜单写入数据库小工具 记录下来以便后面有有类似场景用到 可以做小调整 最多四级路由 永远将最后一级路由写入到url参数中，非最后一级则作为菜单 读取语音文件 菜单名称同时写入到数据库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# -*- coding: utf-8 -*-# __author__ = &apos;zhangcunjun&apos;#descripe 三级菜单四级路由，读取文件初始化菜单到数据库import jsonimport pymysqlimport sysreload(sys)sys.setdefaultencoding(&apos;utf8&apos;)with open(&quot;caidan.json&quot;, &quot;r&quot;) as f: d = json.load(f)#读取中文语言with open(&quot;local_zh.json&quot;, &quot;r&quot;) as e: n = json.load(e)def DelLastChar(str): str_list=list(str) str_list.pop() return &quot;&quot;.join(str_list)conn = pymysql.connect(host=&apos;122.11.58.20&apos;, port=3306, user=&apos;sdkdeveloper&apos;, passwd=&apos;sdkdeveloper&apos;, db=&apos;br_sdk_pro&apos;, charset=&apos;utf8&apos;)cur = conn.cursor()print ntable = &quot;T_SDK_BAS_MENU&quot;for i in range(0, len(d)): sql = &quot;INSERT INTO &quot;+table+&quot; (id,name_zh,router, title, classname,parent_id,type,href, orders) VALUES(&apos;&quot;+str(i+1)+&quot;&apos;,&apos;&quot;+n[d[i][&apos;title&apos;]]+&quot;&apos;, &apos;&quot;+d[i][&apos;id&apos;]+&quot;&apos;,&apos;&quot;+d[i][&apos;title&apos;]+&quot;&apos;, &apos;&quot;+d[i][&apos;classname&apos;]+&quot;&apos;,&apos;&quot;+str(0)+&quot;&apos;,&apos;&quot;+str(1)+&quot;&apos;, &apos;&quot;+d[i][&apos;href&apos;]+&quot;&apos;, &apos;&quot;+str(i+1)+&quot;&apos;);&quot; print sql ; cur.execute(sql.encode(&quot;utf-8&quot;)); if d[i].has_key(&apos;children&apos;) and d[i][&apos;children&apos;]: for j in range(0, len(d[i][&apos;children&apos;])): sec = d[i][&apos;children&apos;][j] ; id = 100*i+j+1 ; if sec.has_key(&apos;children&apos;) and sec[&apos;children&apos;]: third = sec[&apos;children&apos;] url = &quot;&quot; for k in range(0,len(sec[&apos;children&apos;])): if not third[k].has_key(&apos;children&apos;):#如果下面没有children才能作为路由 url = str(third[k][&apos;href&apos;])+&quot;,&quot;+url url=url[:-1] sql2 = &quot;INSERT INTO &quot;+table+&quot; (id,name_zh ,router, title, classname,parent_id,type,href,url, orders) VALUES(&apos;&quot; + str( id) + &quot;&apos;,&apos;&quot;+n[sec[&apos;title&apos;]]+&quot;&apos;, &apos;&quot;+sec[&apos;id&apos;]+&quot;&apos;,&apos;&quot; + sec[&apos;title&apos;] + &quot;&apos;, &apos;&quot; + sec[&apos;classname&apos;] + &quot;&apos;,&apos;&quot; + str(i+1) + &quot;&apos;,&apos;&quot; + str( 2) + &quot;&apos;, &apos;&quot; + sec[&apos;href&apos;] + &quot;&apos;,&apos;&quot;+url+&quot;&apos;, &apos;&quot; + str(id) + &quot;&apos;);&quot; #---------------添加三级菜单 for k in range(0, len(sec[&apos;children&apos;])): third = sec[&apos;children&apos;][k] if third.has_key(&apos;children&apos;) and third[&apos;children&apos;]: id1 = 501+k; url = &quot;&quot; for k in range(0, len(third[&apos;children&apos;])): four = third[&apos;children&apos;][k] if not four.has_key(&apos;children&apos;):#如果下面没有children才能作为路由 url = str(four[&apos;href&apos;]) + &quot;,&quot; + url url = url[:-1] sql3 = &quot;INSERT INTO &quot;+table+&quot; (id,router, parent_id,type,href,url, orders) VALUES(&apos;&quot; + str( id1) + &quot;&apos;, &apos;&quot; + third[&apos;id&apos;] + &quot;&apos;,&apos;&quot; + str(id) + &quot;&apos;,&apos;&quot; + str( 3) + &quot;&apos;, &apos;&quot; + third[&apos;href&apos;] + &quot;&apos;,&apos;&quot; + url + &quot;&apos;, &apos;&quot; + str(k) + &quot;&apos;);&quot; print sql3 cur.execute(sql3.encode(&quot;utf-8&quot;)); #-------------- else: sql2 = &quot;INSERT INTO &quot;+table+&quot; (id,name_zh,router, title, classname,parent_id,type,href, orders) VALUES(&apos;&quot; + str( id) + &quot;&apos;,&apos;&quot;+n[sec[&apos;title&apos;]]+&quot;&apos;,&apos;&quot;+sec[&apos;id&apos;]+&quot;&apos;, &apos;&quot; + sec[&apos;title&apos;] + &quot;&apos;, &apos;&quot; + sec[&apos;classname&apos;] + &quot;&apos;,&apos;&quot; + str(i+1) + &quot;&apos;,&apos;&quot; + str(2) + &quot;&apos;, &apos;&quot; + \\ sec[&apos;href&apos;] + &quot;&apos;, &apos;&quot; + str(id) + &quot;&apos;);&quot; print sql2; cur.execute(sql2.encode(&quot;utf-8&quot;));#添加二级菜单conn.commit()cur.close()conn.close() json菜单如下所示","categories":[{"name":"python","slug":"python","permalink":"http://westbreeze.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://westbreeze.cn/tags/python/"}]},{"title":"springboot整合webService","slug":"springboot整合webservice","date":"2017-02-15T13:19:11.000Z","updated":"2017-12-04T13:11:14.399Z","comments":true,"path":"2017/02/15/springboot整合webservice/","link":"","permalink":"http://westbreeze.cn/2017/02/15/springboot整合webservice/","excerpt":"","text":"springboot整合webService 1.添加CXF依赖包1234567891011&lt;!-- cxf支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt; &lt;version&gt;3.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt; &lt;version&gt;3.1.10&lt;/version&gt;&lt;/dependency&gt; 2.添加webSevice配置12345678910111213141516171819202122232425@Configurationpublic class WebServiceConfig &#123; @Bean public ServletRegistrationBean dispatcherServlet() &#123; return new ServletRegistrationBean(new CXFServlet(), &quot;/test/*&quot;); &#125; @Bean(name = Bus.DEFAULT_BUS_ID) public SpringBus springBus() &#123; return new SpringBus(); &#125; @Bean public UserService userService() &#123; return new UserServiceImpl(); &#125; @Bean public Endpoint endpoint() &#123; EndpointImpl endpoint = new EndpointImpl(springBus(), userService()); endpoint.publish(&quot;/user&quot;); endpoint.getInInterceptors().add(new AuthInterceptor()); return endpoint; &#125; &#125; Springboot整合webService非常简单","categories":[{"name":"接口","slug":"接口","permalink":"http://westbreeze.cn/categories/接口/"}],"tags":[{"name":"webService","slug":"webService","permalink":"http://westbreeze.cn/tags/webService/"}]},{"title":"spring-session redis集群","slug":"无标题Markdown(1)","date":"2016-09-26T17:10:58.000Z","updated":"2017-11-29T04:00:10.899Z","comments":true,"path":"2016/09/27/无标题Markdown(1)/","link":"","permalink":"http://westbreeze.cn/2016/09/27/无标题Markdown(1)/","excerpt":"","text":"近来在使用spring-data-session-redis做web项目session共享的时候碰到一个很奇怪的问题。 redis集群在配置的是三主三从 在使用内网ip没有问题 但是用外网ip连接redis的时候缺报如下错误1Caused by: java.lang.IllegalArgumentException: Node 10.240.47.23:7000 is unknown to cluster 想了很久也想不通 通过从读取配置文件起一步步f8跟踪找到如下代码 JedisClusterConnection类中123456789101112131415161718192021222324public List&lt;String&gt; getConfig(final String pattern) &#123; List mapResult = this.clusterCommandExecutor.executeCommandOnAllNodes(new JedisClusterConnection.JedisClusterCommandCallback() &#123; public List&lt;String&gt; doInCluster(Jedis client) &#123; return client.configGet(pattern); &#125; &#125;).getResults(); ArrayList result = new ArrayList(); Iterator var4 = mapResult.iterator(); while(var4.hasNext()) &#123; NodeResult entry = (NodeResult)var4.next(); String prefix = entry.getNode().asString(); int i = 0; Iterator var8 = ((List)entry.getValue()).iterator(); while(var8.hasNext()) &#123; String value = (String)var8.next(); result.add((i++ % 2 == 0?prefix + &quot;.&quot;:&quot;&quot;) + value); &#125; &#125; return result; &#125; 这段代码会去执行命令连接所有的节点 但是redis在配置主从的时候通过内网ip关联的Cluster 在连接主节点的时候会去找从节点 而本机却连不了内网的ip 因此报这个错误 google clusterCommandExecutor.executeCommandOnAllNodes 找到解决办法 在spring-redis.xml配置文件中添加如下内容： 1&lt;util:constant static-field=&quot;org.springframework.session.data.redis.config.ConfigureRedisAction.NO_OP&quot;/&gt; 其含义是让spring session不在管集群节点信息状况，只管存取就行了 在spring-redis.xml中添加util节点需要添加如下命名空间： 123xmlns:util=&quot;http://www.springframework.org/schema/util&quot;http://www.springframework.org/schema/utilhttp://www.springframework.org/schema/util/spring-util-2.0.xsd","categories":[{"name":"集群与负载","slug":"集群与负载","permalink":"http://westbreeze.cn/categories/集群与负载/"}],"tags":[{"name":"集群与负载","slug":"集群与负载","permalink":"http://westbreeze.cn/tags/集群与负载/"}]},{"title":"Tomcat开启远程调试","slug":"tomcat开启远程调试","date":"2016-03-26T15:02:17.000Z","updated":"2017-12-05T12:03:09.368Z","comments":true,"path":"2016/03/26/tomcat开启远程调试/","link":"","permalink":"http://westbreeze.cn/2016/03/26/tomcat开启远程调试/","excerpt":"","text":"tomcat开启远程调试 有些时候调试线上的的问题 本地不能复现 这时候开启tomcat远程调试比较合适 步骤比较简单：第一步：修改catalina.sh文件 在第一行添加如下内容：1JPDA_OPTS=&apos;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000’ 第二步：开放8000端口123nc -lp 8000 &amp;（打开8000端口） netstat -an | grep 8788 （查看是否打开8000端口 ） 第三步：已调试模式启动tomcat：1./catalina.sh jpda start 第四步：idea添加远程调试服务： eclipse很久没用了 网上去找个图在Run下找到Debug Configurations中文改成对应的信息。 oktomcat远程调试就这么简单","categories":[{"name":"tomcat","slug":"tomcat","permalink":"http://westbreeze.cn/categories/tomcat/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://westbreeze.cn/tags/tomcat/"}]},{"title":"shiro整合CAS","slug":"shiro整合cas","date":"2016-03-21T03:39:32.000Z","updated":"2017-11-01T05:58:52.170Z","comments":true,"path":"2016/03/21/shiro整合cas/","link":"","permalink":"http://westbreeze.cn/2016/03/21/shiro整合cas/","excerpt":"","text":"shiro整合CAS 先说下思路，shiro整合cas，改造shiro原有的登录过程，从cas中获取用户名(不需要密码)，因为密码验证已经在cas中处理了，从cas中获取用户名，构造token，然后继续走shiro该走的流程。最重要的就是重写FormAuthenticationFilter 。第一步：加入jar包 并且在maven中加入shiro-cas核心包即 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-cas&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt; 第二步： 配置application-shiro.xml文件配置过滤器，重写的shiro FormAuthenticationFilter 12&lt;bean id=&quot;authcFilter&quot; class=&quot;com.zcj.filter.CasAuthenticationFilter&quot;&gt; &lt;/bean&gt; 指定权限拦截为这个继承的fillter而不是FormAuthenticationFilter 12345&lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;authcFilter&quot; /&gt; &lt;/util:map&gt;&lt;/property&gt; 最重要的一点，自定义realm中要定义不验证密码，因为cas做的是用户名密码验证，所以在shiro中不必做密码验证，如果这里不配置允许所有认证的话，会导致重定向死循环，因为登录成功之后验证密码肯定不对，因为密码是空的，就又会调到登录页面，而cas又登录过了，就直接又到shiro自定义realm中，又发现密码不对又回去 123456&lt;!-- 項目自定义的Realm --&gt;&lt;bean id=&quot;shiroDbRealm&quot; class=&quot;com.zcj.shiro.ShiroDbRealm&quot;&gt; &lt;property name=&quot;credentialsMatcher&quot;&gt; &lt;bean class=&quot;org.apache.shiro.authc.credential.AllowAllCredentialsMatcher&quot;&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 第三步：重写shiro 的FormAuthenticationFilter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.zcj.filter;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import org.apache.commons.lang3.StringUtils;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.subject.Subject;import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;import org.apache.shiro.web.util.WebUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * CmsAuthenticationFilter自定义登录认证filter */public class CasAuthenticationFilter extends FormAuthenticationFilter &#123; private Logger logger = LoggerFactory.getLogger(CasAuthenticationFilter.class); public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123; boolean isAllowed = isAccessAllowed(request, response, mappedValue); //登录跳转 if (isAllowed &amp;&amp; isLoginRequest(request, response)) &#123; try &#123; issueSuccessRedirect(request, response); &#125; catch (Exception e) &#123; logger.error(&quot;&quot;, e); &#125; return false; &#125; HttpServletRequest req= (HttpServletRequest) request; String name=req.getRemoteUser(); System.out.println(name); if(StringUtils.isNotBlank(req.getRemoteUser()))&#123; AuthenticationToken token = createToken(req.getRemoteUser(),null,request, response); Subject subject = getSubject(request, response); try &#123; subject.login(token); &#125; catch (Exception e) &#123; WebUtils.getAndClearSavedRequest(request); WebUtils.issueRedirect(request, response, &quot;/403.html&quot;, null,true); e.printStackTrace(); return false; &#125; &#125; return isAllowed || onAccessDenied(request, response, mappedValue); &#125;&#125;","categories":[{"name":"单点登录","slug":"单点登录","permalink":"http://westbreeze.cn/categories/单点登录/"}],"tags":[{"name":"shiro-cas","slug":"shiro-cas","permalink":"http://westbreeze.cn/tags/shiro-cas/"}]},{"title":"IDEA快捷键","slug":"idea快捷键","date":"2016-03-06T13:22:03.000Z","updated":"2017-11-29T09:22:09.290Z","comments":true,"path":"2016/03/06/idea快捷键/","link":"","permalink":"http://westbreeze.cn/2016/03/06/idea快捷键/","excerpt":"","text":"近来开始使用IDEA来写代码 感觉比eclipse好用多了 只是开始用 快捷键总是记不住 网上搜了一些记录下来方便查看 Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 Ctrl+[ OR ]，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件 Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 – 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处 Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+”+/-”，当前方法展开、折叠 Ctrl+Shift+”+/-”，全部展开、折叠 【调试部分、编译】 Ctrl+F2，停止 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F10，运行 Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Ctrl+F8，切换行断点 Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构 Ctrl+Shift+C，复制路径 Ctrl+Alt+Shift+C，复制引用，必须选择类名 Ctrl+Alt+Y，同步 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局 Ctrl+Shift+F12，隐藏/恢复所有窗口 Ctrl+F4，关闭 Ctrl+Shift+F4，关闭活动选项卡 Ctrl+Tab，转到下一个拆分器 Ctrl+Shift+Tab，转到上一个拆分器 【重构】 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 【查找】 Ctrl+F，查找 Ctrl+R，替换 F3，查找下一个 Shift+F3，查找上一个 Ctrl+Shift+F，在路径中查找 Ctrl+Shift+R，在路径中替换 Ctrl+Shift+S，搜索结构 Ctrl+Shift+M，替换结构 Alt+F7，查找用法 Ctrl+Alt+F7，显示用法 Ctrl+F7，在文件中查找用法 Ctrl+Shift+F7，在文件中高亮显示用法 贴个贴图 转自：http://www.open-open.com/lib/view/open1396578860887.html","categories":[{"name":"工具","slug":"工具","permalink":"http://westbreeze.cn/categories/工具/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://westbreeze.cn/tags/IDEA/"}]},{"title":"WebService配置（no spring版）","slug":"webService","date":"2016-02-08T13:20:16.000Z","updated":"2017-12-04T13:16:46.803Z","comments":true,"path":"2016/02/08/webService/","link":"","permalink":"http://westbreeze.cn/2016/02/08/webService/","excerpt":"","text":"WebService配置说明（no spring版）1.配置bean记得还是写一下构造方法12345678910111213@XmlRootElement(name=&quot;SynchUser&quot;) public class SynchUser &#123; private String id ; private int appid ; private String applname ; private String creatTime ; private int status ; private int serial ; ``` 2.dao(其中没有注解，这里就不写出来了)3Service接口 import javax.jws.WebMethod;import javax.jws.WebResult;import javax.jws.WebService;@WebServicepublic interface UserSynchI { @WebResult(name = “user”) public String doAddOrDelete(String appid,String md5,String status); @WebMethod public void doResponse(String appid,String md5,String resonse) ; @WebMethod public SynchUser test() ; }1234.service接口实现 import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.annotation.Resource;import javax.jws.WebService;import javax.servlet.http.HttpServletRequest;import javax.xml.ws.BindingType;import javax.xml.ws.WebServiceContext;import javax.xml.ws.soap.SOAPBinding;import org.apache.cxf.transport.http.AbstractHTTPDestination;import org.apache.log4j.Logger;import com.google.gson.Gson;import com.google.gson.reflect.TypeToken;@WebService@BindingType(value = SOAPBinding.SOAP12HTTP_BINDING)public class UserSynchImpl implements UserSynchI { private static Logger logger = Logger.getLogger(UserSynchImpl.class); @Resource(name = &quot;org.apache.cxf.jaxws.context.WebServiceContextImpl&quot;) private WebServiceContext context; public UserSynchImpl() { System.out.println(&quot;userSynchImpl()&quot;); } @Override public String doAddOrDelete(String appid,String md5,String status) { javax.xml.ws.handler.MessageContext ctx = context .getMessageContext(); HttpServletRequest request = (HttpServletRequest) ctx .get(AbstractHTTPDestination.HTTP_REQUEST); String ip = request.getRemoteAddr(); System.out.println(&quot;调用doAddOrDelete()时间是：&quot;+new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(new Date())); PropertiesUtil pu = new PropertiesUtil(&quot;config.properties&quot;) ; Gson gson = new Gson() ; Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;() ; String md5s = Md5Util.md5(pu.getValue(&quot;password&quot;)) ; List&lt;SynchUser&gt; userlist = new ArrayList&lt;SynchUser&gt;(); if(md5s.equals(md5)){ System.out.println(&quot;有权访问doAddOrDelete()&quot;); map.put(&quot;status&quot;, pu.getValue(&quot;succCode&quot;)) ; map.put(&quot;mesg&quot;, &quot;成功&quot;) ; UserDao userDao = new UserDao() ; userlist = userDao.doAddOrDelete(appid,status); map.put(&quot;status&quot;, pu.getValue(&quot;0002&quot;)) ; map.put(&quot;userlist&quot;, userlist) ; } String str = gson.toJson(map) ; /*---------------------------------------日志打印----------------------------------*/ String log = &quot;登录ip为&quot;+ip+&quot;--子系统编号是&quot;+appid+&quot;调用org.jypj.dev.service.UserSynchImpl--doAddOrDelete()--时间是：&quot; +new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(new Date()); if(&quot;1&quot;.equals(status)){ log = log+&quot;--查找新增的用户&quot; ; }else{ log = log+&quot;--查找删除的用户&quot; ; } logger.info(log); String s = &quot;返回的app用户名有这些:&quot; ; for(SynchUser u : userlist){ s = s+u.getApplname()+&quot;,&quot; ; } logger.info(s); /*---------------------------------------日志打印----------------------------------*/ return str; } 125.自定义servlet（集成no spring的servlet） import javax.servlet.ServletConfig;import javax.servlet.annotation.WebServlet;import javax.xml.ws.Endpoint;import org.apache.cxf.transport.servlet.CXFNonSpringServlet;import org.jypj.dev.service.UserSynchImpl;import org.jypj.dev.util.PropertiesUtil;/** Servlet implementation class UserServlet*/@WebServlet(“/UserServlet”)public class UserServlet extends CXFNonSpringServlet{ private static final long serialVersionUID = 1L; @Override protected void loadBus(ServletConfig servletConfig) { PropertiesUtil pu = new PropertiesUtil(&quot;config.properties&quot;) ; super.loadBus(servletConfig); Endpoint.publish(pu.getValue(&quot;wsurl&quot;), new UserSynchImpl()); }} 126.web.xml配置 UserServlet org.jypj.dev.servlet.UserServlet 1 UserServlet /ws/* 1237.config.properties #访问webService的密码password=password8888 #访问相应代码含义 #成功状态码succCode=0000 #响应超时码respTimeoutCode=0001 #异常代码excepCode=0002 #无权访问该代码notAccess=0003 #webService访问路径wsurl=http://172.16.32.16:8086/ws/synchro1234遇到问题： 这种不集成spring的webService如果遇到自己的项目和webService无法同时访问的情况 解决方法：先看正确的配置方法，加了redirect list配置，则可以定向到自己的项目 contextConfigLocation classpath:beans.xml org.springframework.web.context.ContextLoaderListener CXFServlet org.apache.cxf.transport.servlet.CXFServlet redirects-list / redirect-attributes javax.servlet.include.request_uri redirect-servlet-name default 1 CXFServlet /tt/* 12再看看之前无法两者兼得的访问配置方法，这其中就是因为少了配置重定向list的原因 CXFServlet org.apache.cxf.transport.servlet.CXFServlet 1 CXFServlet /* ```","categories":[{"name":"接口","slug":"接口","permalink":"http://westbreeze.cn/categories/接口/"}],"tags":[{"name":"webService","slug":"webService","permalink":"http://westbreeze.cn/tags/webService/"}]},{"title":"webService 动态代理客户端用户密码传输","slug":"webService添加验证","date":"2016-02-08T12:17:19.000Z","updated":"2017-12-04T13:19:04.878Z","comments":true,"path":"2016/02/08/webService添加验证/","link":"","permalink":"http://westbreeze.cn/2016/02/08/webService添加验证/","excerpt":"","text":"1.首先说服务端，服务端是获取用户名密码来验证这是bean.xml配置。里面配置了一个入拦截器1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot; xmlns:jaxrs=&quot;http://cxf.apache.org/jaxrs&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd&quot;&gt; &lt;!-- 引cxf的一些核心配置 --&gt; &lt;import resource=&quot;classpath:META-INF/cxf/cxf.xml&quot; /&gt; &lt;import resource=&quot;classpath:META-INF/cxf/cxf-extension-soap.xml&quot; /&gt; &lt;import resource=&quot;classpath:META-INF/cxf/cxf-servlet.xml&quot; /&gt; &lt;jaxws:endpoint id=&quot;permisWS&quot; implementor=&quot;org.jypj.dev.webService.ApiServcieImpl&quot; address=&quot;/permisws&quot;&gt; &lt;jaxws:inInterceptors&gt; &lt;bean class=&quot;net.jfinal.core.interceptor.CheckUserInterceptor&quot;&gt;&lt;/bean&gt; &lt;/jaxws:inInterceptors&gt; &lt;/jaxws:endpoint&gt; &lt;/beans&gt; 接下来我们来看自定义的这个拦截器CheckUserInterceptor.java12345678910111213141516171819202122232425262728293031323334353637383940414243package net.jfinal.core.interceptor;import javax.xml.namespace.QName;import org.apache.cxf.binding.soap.SoapMessage;import org.apache.cxf.headers.Header;import org.apache.cxf.interceptor.Fault;import org.apache.cxf.phase.AbstractPhaseInterceptor;import org.apache.cxf.phase.Phase;import org.w3c.dom.Element;/** * 查检用户的拦截器 * @author zhangcunjun * time:time:2016.2.07 20:15 */public class CheckUserInterceptor extends AbstractPhaseInterceptor&lt;SoapMessage&gt; &#123; public CheckUserInterceptor() &#123; super(Phase.PRE_PROTOCOL); System.out.println(&quot;CheckUserInterceptor()&quot;); &#125; @Override public void handleMessage(SoapMessage message) throws Fault &#123; Header header = message.getHeader(new QName(&quot;jypj&quot;)); if(header!=null) &#123; Element atguiguEle = (Element) header.getObject(); String name = atguiguEle.getElementsByTagName(&quot;name&quot;).item(0).getTextContent(); String password = atguiguEle.getElementsByTagName(&quot;password&quot;).item(0).getTextContent(); if(&quot;zhangcunjun&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(password)) &#123; System.out.println(&quot;Server 通过拦截器....&quot;); return; &#125; &#125; //不能通过 System.out.println(&quot;Server 没有通过拦截器....&quot;); throw new Fault(new RuntimeException(&quot;请求需要一个正确的用户名和密码dgdfgdfg!&quot;)); &#125;&#125; 我们可以看到在这个拦截器中可以获取到header中获取soap协议中的信息，从中获取用户名和密码来校验，这里面的用户名和密码肯定是自己本地建立配置文件，从配置文件读取。 2.下面我们来看客户端客户端需要的包cxf-2.5.9.jarneethi-3.0.2.jarwsdl4j-1.6.2.jarxalan-2.7.1.jarxmlschema-core-2.0.3.jar 动态代理模式，这是一个工具包，我们可以从下面的代码中看到需要新建一个addUserInterceptors.java，这个其中有个PropertiesUtil 工具包，用来获取配置文件中的用户名和密码，这里就不贴出来了 1234567891011121314151617181920212223242526272829303132333435/* * author:zhangcunjun * time:2016.3.8 17:25 */import java.util.List;import org.apache.cxf.endpoint.Client;import org.apache.cxf.interceptor.Interceptor;import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory;import org.apache.cxf.message.Message;import org.jypj.dev.wsclient.AddUserInterceptor;public class WebServiceUtil &#123; public static String getValue(String methodname,Object[] param)&#123; PropertiesUtil pu = new PropertiesUtil(&quot;wsconfig.properties&quot;) ; JaxWsDynamicClientFactory dcf = JaxWsDynamicClientFactory.newInstance(); Client client = dcf.createClient(pu.getValue(&quot;wsurl&quot;)); List&lt;Interceptor&lt;? extends Message&gt;&gt; outInterceptors = client.getOutInterceptors(); outInterceptors.add(new AddUserInterceptor(pu.getValue(&quot;username&quot;), pu.getValue(&quot;password&quot;))); Object[] res; try&#123; res = client.invoke(&quot;getSysMenu&quot;, param) ; System.out.println(res[0].toString()); return res[0].toString() ; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return null ; &#125; &#125;&#125; 接下来看这个拦截器，当客户端发送请求的时候执行这个拦截器，添加用户名和密码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * author:zhangcunjun * time:2016.3.8 20:15 */import java.util.List;import javax.xml.namespace.QName;import org.apache.cxf.binding.soap.SoapMessage;import org.apache.cxf.headers.Header;import org.apache.cxf.interceptor.Fault;import org.apache.cxf.phase.AbstractPhaseInterceptor;import org.apache.cxf.phase.Phase;import org.apache.xml.utils.DOMHelper;import org.w3c.dom.Document;import org.w3c.dom.Element;/* *webService添加验证用户名拦截器，客户端调用webService接口的时候执行 * */public class AddUserInterceptor extends AbstractPhaseInterceptor&lt;SoapMessage&gt; &#123; private String name; private String password; public AddUserInterceptor(String name, String password) &#123; super(Phase.PRE_PROTOCOL);//准备协议化时拦截 this.name = name; this.password = password; System.out.println(&quot;AddUserInterceptor()....&quot;); &#125; @SuppressWarnings(&quot;deprecation&quot;) @Override public void handleMessage(SoapMessage msg) throws Fault &#123; List&lt;Header&gt; headers = msg.getHeaders(); Document document = DOMHelper.createDocument(); Element rootEle = document.createElement(&quot;jypj&quot;); Element nameELe = document.createElement(&quot;name&quot;); nameELe.setTextContent(name); rootEle.appendChild(nameELe); Element passwordELe = document.createElement(&quot;password&quot;); passwordELe.setTextContent(password); rootEle.appendChild(passwordELe); headers.add(new Header(new QName(&quot;jypj&quot;), rootEle)); System.out.println(&quot;client handleMessage()....&quot;); &#125;&#125; 最后整个测试类测试一下吗，这样就可以获取到webService服务传递过来的值json值了 1234567public class Test &#123; public static void main(String[] args) &#123; Object[] param = &#123;&quot;fengym2824&quot;,&quot;3&quot;&#125; ; WebServiceUtil.getValue(&quot;getSysMenu&quot;, param) ; &#125; &#125;","categories":[{"name":"接口","slug":"接口","permalink":"http://westbreeze.cn/categories/接口/"}],"tags":[{"name":"webService","slug":"webService","permalink":"http://westbreeze.cn/tags/webService/"}]},{"title":"有道云markdown","slug":"有道云markdown","date":"2015-09-27T10:56:32.000Z","updated":"2017-11-29T03:59:30.429Z","comments":true,"path":"2015/09/27/有道云markdown/","link":"","permalink":"http://westbreeze.cn/2015/09/27/有道云markdown/","excerpt":"","text":"使用有道云写markdown​ 1欢迎来到有道云笔记 ——免费，可在桌面版、网页版、手机版之间同步的笔记软件开始使用有道云笔记，只需四步： 1● 点击软件左上角的“新建笔记”按钮； 1● 在新笔记中输入内容，插入图片，有道云笔记还能帮您管理Word, Excel, PPT，PDF等多种附件； 1● 无需手动保存，有道云笔记及时为您自动同步； 1● 通过搜索轻松定位目标笔记。 有道云笔记能帮您：​​ 1● 分类整理笔记，高效管理个人知识。快速搜索，安全备份； 12345678● 自动同步文件，支持图片及文档类附件。无限增长的大存储空间，轻松实现多地点办公；● 用手机版随时随地记录一切趣事和想法，并自动与电脑双向同步；● 一键保存网页中精彩图文，本地存储，永久珍藏有价值的信息。● 微信文章及对话一键保存，扫一扫右边的二维码关注有道云笔记微信公众号吧！● 微博收藏内容一键导入有道云笔记，永久保存。微博首页收藏页面即可找到一键导入有道云笔记。 一键保存网页，点击尝试网页剪报功能点击尝试网页版，手机版等更多版本 微信文章及对话，一键保存。点击查看保存方法。","categories":[],"tags":[]},{"title":"oracle基础服务与命令","slug":"oracle常用命令","date":"2015-09-01T15:49:31.000Z","updated":"2017-12-02T03:19:18.044Z","comments":true,"path":"2015/09/01/oracle常用命令/","link":"","permalink":"http://westbreeze.cn/2015/09/01/oracle常用命令/","excerpt":"","text":"oracle基础服务与命令 oracle存储结构 oracle基础服务 Oracle ORCL VSS Writer Service： OracleDBConsoleorcl： OracleJobSchedulerORCL： OracleMTSRecoveryService： OracleOraDb11g_home1ClrAgent： OracleOraDb11g_home1TNSListener： OracleServiceORCL： 这七个服务的含义分别为： Oracle ORCL VSS Writer Service： Oracle卷映射拷贝写入服务，VSS（Volume Shadow Copy Service）能够让存储基础设备（比如磁盘，阵列等）创建高保真的时间点映像，即映射拷贝（shadowcopy）。它可以在多卷或者单个卷上创建映射拷贝，同时不会影响到系统的系统能。（非必须启动） OracleDBConsoleorcl： Oracle数据库控制台服务，orcl是Oracle的实例标识，默认的实例为orcl。在运行Enterprise Manager（企业管理器OEM）的时候，需要启动这个服务。（非必须启动） OracleJobSchedulerORCL： Oracle作业调度（定时器）服务，ORCL是Oracle实例标识。（非必须启动） OracleMTSRecoveryService： 服务端控制。该服务允许数据库充当一个微软事务服务器MTS、COM/COM+对象和分布式环境下的事务的资源管理器。（非必须启动） OracleOraDb11g_home1ClrAgent： Oracle数据库 .NET扩展服务的一部分。 （非必须启动） OracleOraDb11g_home1TNSListener： 监听器服务，服务只有在数据库需要远程访问的时候才需要。（非必须启动，下面会有详细详解） OracleServiceORCL： 数据库服务(数据库实例)，是Oracle核心服务该服务，是数据库启动的基础， 只有该服务启动，Oracle数据库才能正常启动。(必须启动) oracleOraDb11g_home1ClrAgent ; oracleOraDb11g_home1TNSListener ; OracleServiceOracl ;三个服务必须开启才可以用 常用命令： 创建临时表空间1234create temporary tablespace cms_temp tempfile &apos;C:\\app\\Administrator\\oradata\\orcl\\cms_temp.dbf&apos; size 50m autoextend on next 50m maxsize 20480m extent management local; 创建表空间：12345create tablespace CMS logging datafile &apos;C:\\app\\Administrator\\oradata\\orcl\\CMS.dbf&apos; size 50m autoextend on next 50m maxsize 20480m extent management local; 创建用户并制定默认表空间123create user zhangcj identified by zhangcjpwd default tablespace CMS temporary tablespace cms_temp; 给用户授权：grant connect,resource,dba to EDUC; 清空用户下面的数据：drop user EDUC cascade; 以用户形式导出数据：expdp zhangcj/zhangcjpwd@orcl dumpfile=CMS.dmp impdp命令impdp zhangcj/zhangcjpwd@orcl dumpfile=CMS.dmp 从高版本导出到低版本，指定目标数据库的版本号expdp低版本导出文件，可以被高版本程序识别并导入expdp zhangcj/zhangcjpwd@orcl dumpfile=CMS.dmp version=10.2.0.4.0 删除空的表空间drop tablespace tpas 删除非空表空间drop tablespace tpas including contents and datafiles 更改默认表空间alter user wy2014 default tablespace mytds01 配置全套：1.安装oracle，先装服务端再装客户端，再装plsqldeveloper，都用管理员方式运行 2.安装完毕之后把服务端的监听文件考到客户端里面去 3.用管理员账号登录sys ，密码，登录完成之后创建用户create user 用户名 identified by 密码;然后给改用户赋权限，grant connect,resource,dba to 用户名;一般用户不需要赋dba权限。 3.用管理员账号创建表空间，create tablespace kcsj datafile ‘h:\\app\\ZCJ\\oradata\\kcsj.dbf’ size 500m ; 远程连接oracle服务端：连接远程oracle数据的时候要改动监听文件C:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\NETWORK\\ADMIN 路径下面的tnsnames.ora 和 listener.ora文件 (ADDRESS = (PROTOCOL = TCP)(HOST = ZCJ-Win08-01)(PORT = 1521))两个文件都要改 用户锁定，用sys账号登录选择sysdba，登录进去之后选择EIMS右键edit将锁定勾去掉 挪动表所在空间sql： alter table 用户.tablename move tablespace spaceTwo; 更改某个用户默认表空间alter user zhangcj default tablespace cms_oa;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://westbreeze.cn/categories/数据库/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://westbreeze.cn/tags/oracle/"}]},{"title":"linux开启SMB服务","slug":"linux开启smb服务","date":"2015-09-01T15:49:31.000Z","updated":"2017-11-29T08:45:03.386Z","comments":true,"path":"2015/09/01/linux开启smb服务/","link":"","permalink":"http://westbreeze.cn/2015/09/01/linux开启smb服务/","excerpt":"","text":"linux开启smb服务 组成Samba运行的有两个服务，一个是SMB，另一个是NMB； SMB是Samba 的核心启动服务，主要负责建立 Linux Samba服务器与Samba客户机之间的对话，验证用户身份并提供对文件和打印系统的访问，只有SMB服务启动，才能实现文件的共享，监听139 TCP端口； 而NMB服务是负责解析用的，类似与DNS实现的功能，NMB可以把Linux系统共享的工作组名称与其IP对应起来，如果NMB服务没有启动，就只能通过IP来访问共享文件，监听137和138 UDP端口。 配置这些东西你需要先拥有root权限。首先关闭防火墙：service iptables stop,当初我就因为忽略这个花了一定的时间。另外关闭SELINUX的强制模式：setenforce 0，这个也不可忽略，如果setenforce 1，就好多共享都不成功了。安装Samba: yum install samba samba-client samba-swat 安装过程这里就不贴图了。 查看安装情况： rmp -qa|grep samba Samba服务器安装完毕，会生成配置文件目录/etc/samba和其它一些samba可执行命令工具，/etc/samba/smb.conf是samba的核心配置文件，/etc/init.d/smb是samba的启动/关闭文件。 下面我们来配置Samba服务，有一些注意事项我会强调，请大家注意： 先定位到/etc/samba目录下，把smb.conf备份一下： cp smb.conf smb.conf.bak现在我要把/share目录共享给我的win7机器，打开samba配置文件， vi /etc/samba/smb.conf用shift+g定位到最后一行,可以看到： 修改如下： 好了，保存退出:wq!。 启动smb服务 service smb start 停止 service smb stop 重新启动service smb restart 添加smb用户分析及解决办法：samba用户没有创建或激活，可通过以下方法解决： 添加用户：useradd 你的用户 把用户添加到samba中：smbpasswd -a 你的用户 激活用户：smbpasswd -e 你的用户。","categories":[{"name":"linux","slug":"linux","permalink":"http://westbreeze.cn/categories/linux/"}],"tags":[{"name":"SMB","slug":"SMB","permalink":"http://westbreeze.cn/tags/SMB/"}]},{"title":"MySql命令大全","slug":"mysql文档","date":"2015-08-22T11:03:01.000Z","updated":"2017-11-29T06:56:00.078Z","comments":true,"path":"2015/08/22/mysql文档/","link":"","permalink":"http://westbreeze.cn/2015/08/22/mysql文档/","excerpt":"","text":"1、连接Mysql格式： mysql -h主机地址 -u用户名 －p用户密码 1、连接到本机上的MYSQL。首先打开DOS窗口，然后进入目录mysql\\bin，再键入命令mysql -u root -p，回车后提示你输密码.注意用户名前可以有空格也可以没有空格，但是密码前必须没有空格，否则让你重新输入密码。 如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是： mysql&gt; 2、连接到远程主机上的MYSQL。假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令： mysql -h110.110.110.110 -u root -p 123;（注:u与root之间可以不用加空格，其它也一样） 3、退出MYSQL命令： exit （回车） 2、修改密码格式：mysqladmin -u用户名 -p旧密码 password 新密码 1、给root加个密码ab12。首先在DOS下进入目录mysql\\bin，然后键入以下命令 mysqladmin -u root -password ab12注：因为开始时root没有密码，所以-p旧密码一项就可以省略了。 2、再将root的密码改为djg345。 mysqladmin -u root -p ab12 password djg345 3、增加新用户注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符 格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码” 1、增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令：123456 grant select,insert,update,delete on *.* to [email=test1@”%]test1@”%[/email]” Identified by “abc”;``` 但增加的用户是十分危险的，你想如某个人知道test1的密码，那么他就可以在internet上的任何一台电脑上登录你的mysql数据库并对你的数据可以为所欲为了，解决办法见2。2、增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机），这样用户即使用知道test2的密码，他也无法从internet上直接访问数据库，只能通过MYSQL主机上的web页来访问了。 grant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhost[/email] identified by “abc”; 12如果你不想test2有密码，可以再打一个命令将密码消掉。 grant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhost[/email] identified by “”; 12345678910 #### 4.1 创建数据库注意：创建数据库之前要先连接Mysql服务器命令：create database &lt;数据库名&gt;例1：建立一个名为xhkdb的数据库 mysql&gt; create database xhkdb;例2：创建数据库并分配用户 ①CREATE DATABASE 数据库名; ②GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON 数据库名.* TO 数据库名@localhost IDENTIFIED BY ‘密码’; ③SET PASSWORD FOR ‘数据库名’@’localhost’ = OLD_PASSWORD(‘密码’);123456789101112依次执行3个命令完成数据库创建。注意：中文 “密码”和“数据库”是户自己需要设置的。#### 4.2 显示数据库命令：show databases （注意：最后有个s）mysql&gt; show databases;注意：为了不再显示的时候乱码，要修改数据库默认编码。以下以GBK编码页面为例进行说明：1、修改MYSQL的配置文件：my.ini里面修改default-character-set=gbk2、代码运行时修改： ①Java代码：jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=gbk ②PHP代码：header(“Content-Type:text/html;charset=gb2312”); ③C语言代码：int mysql_set_character_set( MYSQL mysql, char csname)；12345678910该 函数用于为当前连接设置默认的字符集。字符串csname指定了1个有效的字符集名称。连接校对成为字符集的默认校对。该函数的工作方式与SET NAMES语句类似，但它还能设置mysql- &gt; charset的值，从而影响了由mysql_real_escape_string() 设置的字符集。#### 4.3 删除数据库命令：drop database &lt;数据库名&gt;例如：删除名为 xhkdb的数据库mysql&gt; drop database xhkdb;例子1：删除一个已经确定存在的数据库 mysql&gt; drop database drop_database; Query OK, 0 rows affected (0.00 sec) 例子2：删除一个不确定存在的数据库 mysql&gt; drop database drop_database; ERROR 1008 (HY000): Can’t drop database ‘drop_database’; database doesn’t exist //发生错误，不能删除’drop_database’数据库，该数据库不存在。 mysql&gt; drop database if exists drop_database; Query OK, 0 rows affected, 1 warning (0.00 sec)//产生一个警告说明此数据库不存在 mysql&gt; create database drop_database; Query OK, 1 row affected (0.00 sec) mysql&gt; drop database if exists drop_database;//if exists 判断数据库是否存在，不存在也不产生错误 Query OK, 0 rows affected (0.00 sec)1234567891011#### 4.4 连接数据库命令： use &lt;数据库名&gt;例如：如果xhkdb数据库存在，尝试存取它： mysql&gt; use xhkdb;屏幕提示：Database changeduse 语句可以通告MySQL把db_name数据库作为默认（当前）数据库使用，用于后续语句。该数据库保持为默认数据库，直到语段的结尾，或者直到发布一个不同的USE语句： mysql&gt; USE db1; mysql&gt; SELECT COUNT() FROM mytable; # selects from db1.mytable mysql&gt; USE db2; mysql&gt; SELECT COUNT() FROM mytable; # selects from db2.mytable12使用USE语句为一个特定的当前的数据库做标记，不会阻碍您访问其它数据库中的表。下面的例子可以从db1数据库访问作者表，并从db2数据库访问编辑表： mysql&gt; USE db1; mysql&gt; SELECT author_name,editor_name FROM author,db2.editor -&gt; WHERE author.editor_id = db2.editor.editor_id;1234567891011121314USE语句被设立出来，用于与Sybase相兼容。有些网友问到，连接以后怎么退出。其实，不用退出来，use 数据库后，使用show databases就能查询所有数据库，如果想跳到其他数据库，用 use 其他数据库名字就可以了。#### 4.5 当前选择的数据库命令：mysql&gt; select database();MySQL中SELECT命令类似于其他编程语言里的print或者write，你可以用它来显示一个字符串、数字、数学表达式的结果等等。如何使用MySQL中SELECT命令的特殊功能？1.显示MYSQL的版本 mysql&gt; select version();+———————–+| version() |+———————–+| 6.0.4-alpha-community |+———————–+1 row in set (0.02 sec) 显示当前时间mysql&gt; select now();+———————+| now() |+———————+| 2009-09-15 22:35:32 |+———————+1 row in set (0.04 sec) 显示年月日SELECT DAYOFMONTH(CURRENT_DATE);+————————–+| DAYOFMONTH(CURRENT_DATE) |+————————–+| 15 |+————————–+1 row in set (0.01 sec) SELECT MONTH(CURRENT_DATE);+———————+| MONTH(CURRENT_DATE) |+———————+| 9 |+———————+1 row in set (0.00 sec) SELECT YEAR(CURRENT_DATE);+——————–+| YEAR(CURRENT_DATE) |+——————–+| 2009 |+——————–+1 row in set (0.00 sec) 显示字符串mysql&gt; SELECT “welecome to my blog!”;+———————-+| welecome to my blog! |+———————-+| welecome to my blog! |+———————-+1 row in set (0.00 sec) 当计算器用select ((4 4) / 10 ) + 25;+———————-+| ((4 4) / 10 ) + 25 |+———————-+| 26.60 |+———————-+1 row in set (0.00 sec) 126. 串接字符串 select CONCAT(f_name, “ “, l_name)AS Namefrom employee_datawhere title = ‘Marketing Executive’;+—————+| Name |+—————+| Monica Sehgal || Hal Simlai || Joseph Irvine |+—————+3 rows in set (0.00 sec)123456注意：这里用到CONCAT()函数，用来把字符串串接起来。另外，我们还用到以前学到的AS给结果列&apos;CONCAT(f_name, &quot; &quot;, l_name)&apos;起了个假名。5.1 创建数据表命令：create table &lt;表名&gt; ( &lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]);例如，建立一个名为MyClass的表， 字段名 数字类型 数据宽度 是否为空 是否主键 自动增加 默认值id int 4 否 primary key auto_incrementname char 20 否sex int 4 否 0degree double 16 是 mysql&gt; create table MyClass( id int(4) not null primary key auto_increment,name char(20) not null,sex int(4) not null default ‘0’,degree double(16,2));123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#### 5.3 删除数据表命令：drop table &lt;表名&gt;例如：删除表名为 MyClass 的表 mysql&gt; drop table MyClass;DROP TABLE用于取消一个或多个表。您必须有每个表的DROP权限。所有的表数据和表定义会被取消，所以使用本语句要小心！注意：对于一个带分区的表，DROP TABLE会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。DROP TABLE还会取消与被取消的表有关联的分区定义（.par）文件。对与不存在的表，使用IF EXISTS用于防止错误发生。当使用IF EXISTS时，对于每个不存在的表，会生成一个NOTE。RESTRICT和CASCADE可以使分区更容易。目前，RESTRICT和CASCADE不起作用。#### 5.4 表插入数据命令：insert into &lt;表名&gt; [( &lt;字段名1&gt;[,..&lt;字段名n &gt; ])] values ( 值1 )[, ( 值n )]例如：往表 MyClass中插入二条记录, 这二条记录表示：编号为1的名为Tom的成绩为96.45, 编号为2 的名为Joan 的成绩为82.99， 编号为3 的名为Wang 的成绩为96.5。 mysql&gt; insert into MyClass values(1,&apos;Tom&apos;,96.45),(2,&apos;Joan&apos;,82.99), (2,&apos;Wang&apos;, 96.59);注意：insert into每次只能向表中插入一条记录。5.5 查询表中的数据1)、查询所有行命令： select &lt;字段1，字段2，...&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt;例如：查看表 MyClass 中所有数据 mysql&gt; select * from MyClass;2）、查询前几行数据例如：查看表 MyClass 中前2行数据mysql&gt; select * from MyClass order by id limit 0,2;select一般配合where使用，以查询更精确更复杂的数据。#### 5.6 删除表中数据 命令：delete from 表名 where 表达式例如：删除表 MyClass中编号为1 的记录mysql&gt; delete from MyClass where id=1;下面是一个删除数据前后表的对比。FirstName LastName AgePeter Griffin 35Glenn Quagmire 33 #### 5.8 增加字段 命令：alter table 表名 add字段 类型 其他;例如：在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为0 mysql&gt; alter table MyClass add passtest int(4) default ‘0’ 加索引 mysql&gt; alter table 表名 add index 索引名 (字段名1[，字段名2 …]);例子： mysql&gt; alter table employee add index emp_name (name); 加主关键字的索引 mysql&gt; alter table 表名 add primary key (字段名);例子： mysql&gt; alter table employee add primary key(id); 加唯一限制条件的索引 mysql&gt; alter table 表名 add unique 索引名 (字段名);例子： mysql&gt; alter table employee add unique emp_name2(cardnumber); 删除某个索引 mysql&gt; alter table 表名 drop index 索引名;例子： mysql&gt;alter table employee drop index emp_name; 增加字段：mysql&gt; ALTER TABLE table_name ADD field_name field_type; 修改原字段名称及类型：mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 删除字段：MySQL ALTER TABLE table_name DROP field_name;5.9 修改表名命令：rename table 原表名 to 新表名; 例如：在表MyClass名字更改为YouClass mysql&gt; rename table MyClass to YouClass; 当你执行 RENAME 时，你不能有任何锁定的表或活动的事务。你同样也必须有对原初表的 ALTER 和 DROP 权限，以及对新表的 CREATE 和 INSERT 权限。 如果在多表更名中，MySQL 遭遇到任何错误，它将对所有被更名的表进行倒退更名，将每件事物退回到最初状态。 RENAME TABLE 在 MySQL 3.23.23 中被加入。6、备份数据库命令在DOS的[url=file://\\mysql\\bin]\\mysql\\bin[/url]目录下执行 1.导出整个数据库导出文件默认是存在mysql\\bin目录下 mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名 mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql 2.导出一个表 mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名 mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql 3.导出一个数据库结构 mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql -d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 4.带语言参数导出 mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql 例如，将aaa库备份到文件back_aaa中： [root@test1 root]# cd /home/data/mysql [root@test1 mysql]# mysqldump -u root -p –opt aaa &gt; back_aaa7.1 一个建库和建表的实例1drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER( id int(3) auto_increment not null primary key, name char(10) not null, address varchar(50) default ‘深圳’, year date); //建表结束 //以下为插入字段insert into teacher values(”,’allen’,’大连一中’,’1976-10-10′);insert into teacher values(”,’jack’,’大连二中’,’1975-12-23′); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。1、你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\\下，并在DOS状态进入目录[url=file://\\mysql\\bin]\\mysql\\bin[/url]，然后键入以下命令： mysql -uroot -p密码 &lt; c:\\school.sql如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 2、或者进入命令行后使用 mysql&gt; source c:\\school.sql; 也可以将school.sql文件导入数据库中。 7.2 一个建库和建表的实例2drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER( id int(3) auto_increment not null primary key, name char(10) not null, address varchar(50) default ‘’深圳’’, year date); //建表结束 //以下为插入字段insert into teacher values(‘’’’,’’glchengang’’,’’深圳一中’’,’’1976-10-10’’);insert into teacher values(‘’’’,’’jack’’,’’深圳一中’’,’’1975-12-23’’); 注：在建表中1、将ID设为长度为3的数字字段:int(3)；并让它每个记录自动加一:auto_increment；并不能为空:not null；而且让他成为主字段primary key。 2、将NAME设为长度为10的字符字段 3、将ADDRESS设为长度50的字符字段，而且缺省值为深圳。 4、将YEAR设为日期字段。``` 转载来源： http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html","categories":[{"name":"常用文档","slug":"常用文档","permalink":"http://westbreeze.cn/categories/常用文档/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://westbreeze.cn/tags/Mysql/"}]},{"title":"centos下安装nginx","slug":"无标题Markdown","date":"2015-08-13T12:09:01.000Z","updated":"2017-12-04T13:15:40.464Z","comments":true,"path":"2015/08/13/无标题Markdown/","link":"","permalink":"http://westbreeze.cn/2015/08/13/无标题Markdown/","excerpt":"","text":"centos下安装nginx Nginx 是 C语言 开发，建议在 Linux 上运行，当然，也可以安装 Windows 版本，本篇则使用 CentOS 7 作为安装环境。一. gcc 安装安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：yum install gcc-c++ 二. PCRE pcre-devel 安装PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：yum install -y pcre pcre-devel 三. zlib 安装zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。yum install -y zlib zlib-devel 四. OpenSSL 安装OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。yum install -y openssl openssl-devel 五.配置./configure 六.编译安装make &amp;&amp; make install 碰到错误查一查解决一下就行了","categories":[{"name":"nginx","slug":"nginx","permalink":"http://westbreeze.cn/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://westbreeze.cn/tags/nginx/"}]},{"title":"写在前面","slug":"写在前面","date":"2015-03-25T17:10:58.000Z","updated":"2017-12-02T03:25:10.796Z","comments":true,"path":"2015/03/26/写在前面/","link":"","permalink":"http://westbreeze.cn/2015/03/26/写在前面/","excerpt":"","text":"​ 以前也在各种博客网上零星的写过一些博客。 ​ 近来想把平时做的笔记整理一下，因此创建一个博客，整理的过程也是一种回顾。 ​","categories":[],"tags":[{"name":"westbreeze","slug":"westbreeze","permalink":"http://westbreeze.cn/tags/westbreeze/"}]}]}