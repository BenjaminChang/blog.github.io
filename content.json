{"meta":{"title":"westbreeze个人博客","subtitle":"兰亭无绪，独饮清风","description":null,"author":"westbreeze","url":"http://westbreeze.cn"},"pages":[{"title":"关于我","date":"2017-08-28T15:08:06.000Z","updated":"2017-08-28T15:11:34.310Z","comments":true,"path":"about/index.html","permalink":"http://westbreeze.cn/about/index.html","excerpt":"","text":"​ 以前也在各种博客网上零星的写过一些博客。 ​ 近来想把平时做的笔记整理一下，因此创建一个博客，整理的过程也是一种回顾。 ​"}],"posts":[{"title":"多域名指向统一个nginx配置","slug":"多域名指向同一个nginx","date":"2017-04-01T10:45:36.000Z","updated":"2017-11-01T06:29:41.679Z","comments":true,"path":"2017/04/01/多域名指向同一个nginx/","link":"","permalink":"http://westbreeze.cn/2017/04/01/多域名指向同一个nginx/","excerpt":"","text":"多个域名指向同一个nginx配置 server { listen 80; server_name test1.test.com test2.test.com; #charset koi8-r; #access_log logs/host.access.log main; location ^~ /sdk/ { proxy_pass http://passport; proxy_redirect off ; proxy_set_header Host $host:80; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; } } 这里遇到一个问题 最后一个域名后面加个空格会报错","categories":[{"name":"nginx","slug":"nginx","permalink":"http://westbreeze.cn/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://westbreeze.cn/tags/nginx/"}]},{"title":"spring-session redis集群","slug":"无标题Markdown(1)","date":"2016-09-26T17:10:58.000Z","updated":"2017-11-29T04:00:10.899Z","comments":true,"path":"2016/09/27/无标题Markdown(1)/","link":"","permalink":"http://westbreeze.cn/2016/09/27/无标题Markdown(1)/","excerpt":"","text":"近来在使用spring-data-session-redis做web项目session共享的时候碰到一个很奇怪的问题。 redis集群在配置的是三主三从 在使用内网ip没有问题 但是用外网ip连接redis的时候缺报如下错误1Caused by: java.lang.IllegalArgumentException: Node 10.240.47.23:7000 is unknown to cluster 想了很久也想不通 通过从读取配置文件起一步步f8跟踪找到如下代码 JedisClusterConnection类中123456789101112131415161718192021222324public List&lt;String&gt; getConfig(final String pattern) &#123; List mapResult = this.clusterCommandExecutor.executeCommandOnAllNodes(new JedisClusterConnection.JedisClusterCommandCallback() &#123; public List&lt;String&gt; doInCluster(Jedis client) &#123; return client.configGet(pattern); &#125; &#125;).getResults(); ArrayList result = new ArrayList(); Iterator var4 = mapResult.iterator(); while(var4.hasNext()) &#123; NodeResult entry = (NodeResult)var4.next(); String prefix = entry.getNode().asString(); int i = 0; Iterator var8 = ((List)entry.getValue()).iterator(); while(var8.hasNext()) &#123; String value = (String)var8.next(); result.add((i++ % 2 == 0?prefix + &quot;.&quot;:&quot;&quot;) + value); &#125; &#125; return result; &#125; 这段代码会去执行命令连接所有的节点 但是redis在配置主从的时候通过内网ip关联的Cluster 在连接主节点的时候会去找从节点 而本机却连不了内网的ip 因此报这个错误 google clusterCommandExecutor.executeCommandOnAllNodes 找到解决办法 在spring-redis.xml配置文件中添加如下内容： 1&lt;util:constant static-field=&quot;org.springframework.session.data.redis.config.ConfigureRedisAction.NO_OP&quot;/&gt; 其含义是让spring session不在管集群节点信息状况，只管存取就行了 在spring-redis.xml中添加util节点需要添加如下命名空间： 123xmlns:util=&quot;http://www.springframework.org/schema/util&quot;http://www.springframework.org/schema/utilhttp://www.springframework.org/schema/util/spring-util-2.0.xsd","categories":[{"name":"集群与负载","slug":"集群与负载","permalink":"http://westbreeze.cn/categories/集群与负载/"}],"tags":[{"name":"集群与负载","slug":"集群与负载","permalink":"http://westbreeze.cn/tags/集群与负载/"}]},{"title":"shiro整合CAS","slug":"shiro整合cas","date":"2016-03-21T03:39:32.000Z","updated":"2017-11-01T05:58:52.170Z","comments":true,"path":"2016/03/21/shiro整合cas/","link":"","permalink":"http://westbreeze.cn/2016/03/21/shiro整合cas/","excerpt":"","text":"shiro整合CAS 先说下思路，shiro整合cas，改造shiro原有的登录过程，从cas中获取用户名(不需要密码)，因为密码验证已经在cas中处理了，从cas中获取用户名，构造token，然后继续走shiro该走的流程。最重要的就是重写FormAuthenticationFilter 。第一步：加入jar包 并且在maven中加入shiro-cas核心包即 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-cas&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt; 第二步： 配置application-shiro.xml文件配置过滤器，重写的shiro FormAuthenticationFilter 12&lt;bean id=&quot;authcFilter&quot; class=&quot;com.zcj.filter.CasAuthenticationFilter&quot;&gt; &lt;/bean&gt; 指定权限拦截为这个继承的fillter而不是FormAuthenticationFilter 12345&lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;authcFilter&quot; /&gt; &lt;/util:map&gt;&lt;/property&gt; 最重要的一点，自定义realm中要定义不验证密码，因为cas做的是用户名密码验证，所以在shiro中不必做密码验证，如果这里不配置允许所有认证的话，会导致重定向死循环，因为登录成功之后验证密码肯定不对，因为密码是空的，就又会调到登录页面，而cas又登录过了，就直接又到shiro自定义realm中，又发现密码不对又回去 123456&lt;!-- 項目自定义的Realm --&gt;&lt;bean id=&quot;shiroDbRealm&quot; class=&quot;com.zcj.shiro.ShiroDbRealm&quot;&gt; &lt;property name=&quot;credentialsMatcher&quot;&gt; &lt;bean class=&quot;org.apache.shiro.authc.credential.AllowAllCredentialsMatcher&quot;&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 第三步：重写shiro 的FormAuthenticationFilter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.zcj.filter;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import org.apache.commons.lang3.StringUtils;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.subject.Subject;import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;import org.apache.shiro.web.util.WebUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * CmsAuthenticationFilter自定义登录认证filter */public class CasAuthenticationFilter extends FormAuthenticationFilter &#123; private Logger logger = LoggerFactory.getLogger(CasAuthenticationFilter.class); public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123; boolean isAllowed = isAccessAllowed(request, response, mappedValue); //登录跳转 if (isAllowed &amp;&amp; isLoginRequest(request, response)) &#123; try &#123; issueSuccessRedirect(request, response); &#125; catch (Exception e) &#123; logger.error(&quot;&quot;, e); &#125; return false; &#125; HttpServletRequest req= (HttpServletRequest) request; String name=req.getRemoteUser(); System.out.println(name); if(StringUtils.isNotBlank(req.getRemoteUser()))&#123; AuthenticationToken token = createToken(req.getRemoteUser(),null,request, response); Subject subject = getSubject(request, response); try &#123; subject.login(token); &#125; catch (Exception e) &#123; WebUtils.getAndClearSavedRequest(request); WebUtils.issueRedirect(request, response, &quot;/403.html&quot;, null,true); e.printStackTrace(); return false; &#125; &#125; return isAllowed || onAccessDenied(request, response, mappedValue); &#125;&#125;","categories":[{"name":"单点登录","slug":"单点登录","permalink":"http://westbreeze.cn/categories/单点登录/"}],"tags":[{"name":"shiro-cas","slug":"shiro-cas","permalink":"http://westbreeze.cn/tags/shiro-cas/"}]},{"title":"有道云markdown","slug":"有道云markdown","date":"2015-09-27T10:56:32.000Z","updated":"2017-11-29T03:59:30.429Z","comments":true,"path":"2015/09/27/有道云markdown/","link":"","permalink":"http://westbreeze.cn/2015/09/27/有道云markdown/","excerpt":"","text":"使用有道云写markdown​ 1欢迎来到有道云笔记 ——免费，可在桌面版、网页版、手机版之间同步的笔记软件开始使用有道云笔记，只需四步： 1● 点击软件左上角的“新建笔记”按钮； 1● 在新笔记中输入内容，插入图片，有道云笔记还能帮您管理Word, Excel, PPT，PDF等多种附件； 1● 无需手动保存，有道云笔记及时为您自动同步； 1● 通过搜索轻松定位目标笔记。 有道云笔记能帮您：​​ 1● 分类整理笔记，高效管理个人知识。快速搜索，安全备份； 12345678● 自动同步文件，支持图片及文档类附件。无限增长的大存储空间，轻松实现多地点办公；● 用手机版随时随地记录一切趣事和想法，并自动与电脑双向同步；● 一键保存网页中精彩图文，本地存储，永久珍藏有价值的信息。● 微信文章及对话一键保存，扫一扫右边的二维码关注有道云笔记微信公众号吧！● 微博收藏内容一键导入有道云笔记，永久保存。微博首页收藏页面即可找到一键导入有道云笔记。 一键保存网页，点击尝试网页剪报功能点击尝试网页版，手机版等更多版本 微信文章及对话，一键保存。点击查看保存方法。","categories":[],"tags":[]},{"title":"写在前面","slug":"写在前面","date":"2015-08-25T17:10:58.000Z","updated":"2017-11-29T03:59:49.953Z","comments":true,"path":"2015/08/26/写在前面/","link":"","permalink":"http://westbreeze.cn/2015/08/26/写在前面/","excerpt":"","text":"​ 以前也在各种博客网上零星的写过一些博客。 ​ 近来想把平时做的笔记整理一下，因此创建一个博客，整理的过程也是一种回顾。 ​","categories":[{"name":"博客说明","slug":"博客说明","permalink":"http://westbreeze.cn/categories/博客说明/"}],"tags":[{"name":"westbreeze","slug":"westbreeze","permalink":"http://westbreeze.cn/tags/westbreeze/"}]}]}